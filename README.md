# Cydroïd <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/csharp/csharp-original.svg" height="50" alt="csharp" align="right" /> <img width="12" /> <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/unity/unity-original.svg" height="50" alt="unity" align="right" />

**Projet NSI 2022-2023**

---

## Informations

**Auteurs :** _@notpolarstar_ & _@Luzog78_

<br>

**Moteur de Jeu :** _`Unity 2021.2.7f1`_

**Editeur de Code :** _`Visual Studio Code 2019`_

**Logiciels de Textures :** _[`Paint.NET`]_

---

<br><br>

## Préambule

Nous sommes le 31 février 2k153.<br>
Les jeunes de nos jours ne veulent plus travailler. La closeIA a donc créé une intelligence artificielle, nommée Cydroïd, pour faire les tâches à leur place.<br>
La conception de ces "Super IA" est très complexe et développe particulièrement l'aspect émotionnel et la personnalité des droïds.<br>
Bienvenue à vous, Cydroïd #713705.<br>

---

<br><br>

## Déroulement

<br>



## Semaine 1 <a href="#semaine-2" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%87%EF%B8%8F%20NEXT&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a> <a href="#semaine-1" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%86%EF%B8%8F%20PREV&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a>

<div align="center">

  ### Création du projet

  > Trouver l'idée...<br>
    Pas facile...

</div>

- **Premières idées :**

  - Remake d'un classique + Ajouter des fonctionnalités
    - PacMan
    - Minesweeper
    - Tetris
    - Pong
    - ...
    > **Conclusion :** *Refaire le déjà fait... surtout des millions de fois, c'est nul.*

  <br>

  - Pourquoi pas un logiciel utile ?
    - Finance
    - Maps
    - Chat
    > **Conclusion :** *C'est chiant. >> Personne ne l'utilisera. Alors autant s'amuser.*

  <br>

  - Donc un jeu plus complexe
    - Bataille Navale
    - Echecs
    > **Conclusion :** *La pour le coup, on changera presque rien (juste l'interface) donc c'est encore pire que les premières idées.*

  <br>

  - ***Il faut donc en créer un !*** Mais comment ? Avec quels critères ?
    - Aventure ? Plateforme ? Combat ? QTE ?
    - RPG ? Hach'n'Slash ? MMO ? Tycoon ?
    - En FPS ou en 3eme personne ?
    - Medieval ? Cyberpunk ? Fantastique ? Fantaisy ?
    > **Conclusion :** *Bonne idée mais il faut creuser le sujet.*<br>*On a définitivement pas assez de ressource pour commencer quelconque travail.*


<br><br><br>


## Semaine 2 <a href="#semaine-3" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%87%EF%B8%8F%20NEXT&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a> <a href="#semaine-1" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%86%EF%B8%8F%20PREV&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a>

<div align="center">

  ### Création du projet

  > Cette fois, on est sur la bonne voie.

</div>

- Ça n'a pas réussi à avancer. Rien ne bougeait, on ne trouvait pas d'idée... Jusqu'à la séance du jeudi !

- Comme ca faisait un petit temps qu'il fallait commencer, on s'est posé plusieurs questions et chacun notre tour et l'autre devait répondre instinctivement :

  - **Question :** Jeux ou logiciel ?
    > **Réponse :** *Un jeu c'est plus sympa. Plus fun ! ^^*

  <br>

  - **Question :** Deux ou trois dimensions ?
    > **Réponse :** *On fera de la 3D !*

  <br>

  - **Question :** Le moteur de jeu ?
    - Unreal Engine : *Sympa pour de la 3D mais peu de docs.*
    - Godot : *Parfait mais pour de la 2D.*
    - Unity : *Semble très polyvalent et très connu. Donc pourquoi pas ?*
    > **Réponse :** *On a beaucoup hésité mais finalement Unity semble être le bon choix.*

  <br>

  - **Question :** Première ou troisième personne ?
    > **Réponse :** *Troisième.*

  <br>

  - **Question :** Type ?
    - Shooter : *Nop, pas en 3ème personne + trop de boulot (manipuler des entités avec des IA).*
    - Arcade : *Pourquoi pas mais fait, fait, et surfait donc bof pour l'originalité.*
    - Multijoueur : *Trop galère sur Unity et on pourra peut-être pas le tester en classe donc non.*
    - Enigme : *Bah en vrai ça nous tente beaucoup ! A la fois complexe mais cool à développer. c'est parfait !*
    > **Réponse :** *Donc un jeu de réflexion (énigme mais aventure également).*

  <br>

  - **Question :** Style et contexte ?
    > **Réponse :** *L'univers de Portal n'est vraiment pas mal à exploiter... Peut-être essayer de retrouver une ambiance semblable à celle-là.*<br>
    *Et puis simuler un monde ultra futuriste (où les machines seraient omniprésentes et omniscientes), ça pourrait être pas mal.*

  <br>

  - **Question :** Histoire ? Scénario ?
    > **Réponse :** *Comme choisi plus tôt, on part sur le fait que le personnage principal est un cyborg créé afin de servir au mieux les humains et que pour être en service, il devait passer en révisions toutes ses capacités motrices et intellectuelles.*

  <br>

- Sur ce, nous avions une bonne base afin de commencer notre travail.


<br><br><br>


## Semaine 3
<a href="#semaine-4" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%87%EF%B8%8F%20NEXT&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a> <a href="#semaine-2" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%86%EF%B8%8F%20PREV&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a>

<div align="center">

  ### Débuts avec l'IDE

  > Une découverte un peu difficile.
  > Mais au moins, on finira bilingue !

</div>

- Durant cette semaine, la plupart de nos soirées se résumait à voir encore et encore de multiples tutoriels sur l'utilisation de *Unity*.

- Un point positif : on remarque vite que le niveau d'anglais s'améliore énormément et super vite !

- Donc après première ouverture de Unity, ce qu'on constate :
  - L'interface semble beaucoup trop complexe,
  - Le bouton "Play" ne fonctionne pas,
  - Des problèmes dans la console,
  - Impossible de se déplacer dans l'environnement.
  > Bref tout ça fait qu'on en a déjà marre. Après à peine quelques minutes.

![img](/resources/1373.png?raw=true)

- Mais on prend notre courage à deux mains et on avance.

- La routine commence à s'installer :
  1. Analyser une erreur de la console,
  2. Tenter de le résoudre,
  3. Ne pas y arriver donc chercher sur les forums,
  > Merci d'ailleurs aux contributeurs de [Stack Overflow](https://stackoverflow.com/) et du [Unity Forum](https://forum.unity.com/) sur lesquels nous avons passé plusieurs dizaines d'heures.
  4. Enfin trouver une solution miraculeuse (après une ou deux bonnes heures),
  5. Et recommencer !

- Durant ces longs moments de test et de fails, nous avons appris les bases du logiciel :

  - Comment créer un objet,

  - Comment fonctionne l'architecture,

  - Qu'est-ce qu'un objet,
  > **Petit a parte :** *En vérité, c'est très ingénieux : un objet, quel qu'il soit, n'est qu'une boîte vide dans laquelle on ajoute les différents composants dont on a besoin.*<br>
  *Chaque objet __DOIT__ posséder le composant __TRANSFORM__ qui indique une __position__, une __roation__ et une __echelle__ de taille.*<br>
  *Maintenant, si je veux pourvoir __voir__ mon objet, il lui faut un composant __MESH__ : "mesh" c'est la surface sur laquelle va être affichée une texture.*<br>
  *De plus, si je veux un objet qui peut interagir avec l'environnement, il faut un composant __COLLIDER__ afin de savoir quand 2 objets entrent en contact (le plus utilisé étant le __MESH COLLIDER__ qui crée une collision à partir de la surface de l'objet)*<br>
  *Et enfin, si on veut créer un solide, avec de la physique (pour qu'il puisse "tomber" par exemple), il lui faut ajouter le composant __RIGID BODY__ qui gère la masse de l'objet, sa vélocité etc.*

  - Comment manipuler la caméra

  - Comment se déplacer dans l'éditeur pour mieux comprendre et se situer dans l'environnement.

  - etc.

![img](/resources/3955.png?raw=true)

- Tout ce processus nous a pris la semaine entière et nous ne sommes même pas à 1% de l'entière compréhension du logiciel.

- Objectif pour la semaine prochaine : créer un joueur, pouvoir le déplacer et gérer.... La ***gravité*** ........ *(explications dans le prochain épisode)*


<br><br><br>


## Semaine 4 <a href="#semaine-5" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%87%EF%B8%8F%20NEXT&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a> <a href="#semaine-3" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%86%EF%B8%8F%20PREV&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a>

<div align="center">

  ### Premiers pas !

  > On avance assez bien !
  > Même si la physique c'est pas facile.

  ### Objectif : Créer un joueur contrôlable.

</div>

- Pour cette étape, rien de plus simple *(lol)* :

  - Pour le corps, on choisit l'objet __capsule__.
  > C'est l'objet primitif qui ressemble le plus à un corps.

  <br>

  - Ensuite, il faut ajouter une petite flopée de __colliders__ afin de gérer les collisions de notre joueur.
  > C'est effectivement bien mieux s'il ne traverse pas les murs.

    - Le __collider principal__, qui englobe au mieux le personnage.<br>
    Il gère les collisions avec les sols et toutes les autres collisions (non spécifiées plus bas).

    - Le __collider mural__, qui est plus petit en hauteur mais très légèrement bombé afin de gérer les collisions avec les murs.
    > En effet, on a besoin d'un autre collider pour les murs car la physique de Unity fait en sorte que par défaut, si notre vélocité augmente contre un mur par exemple, elle va juste être mise à zéro : si le joueur le fait en sautant, il vole.<br>
    C'est l'effet de "friction" qui influe sur cette partie. On applique donc un filtre permettant de retirer toute friction à notre collider mural.<br>
    **Attention :** il ne faut pas le faire sur le collider principal car sinon, impossible de s'arrêter : les frictions avec le sol n'existent plus.

    - Les __colliders de biais__, utilisés pour détecter les collisions quand le sol est en biais, situés en bas du personnage.
    > Quand le joueur, en jouant avec la gravité, se retrouve à marcher sur 2 murs, il subit beaucoup trop de frictions : il ne peut plus avancer.<br>
    On applique donc à ces colliers le filtre permettant de retirer toutes les frictions.

  <br>

  - Et enfin, on définit un point d'accroche qui servira plus tard pour la caméra.

  <br>

![img](/resources/2288.png?raw=true)
![img](/resources/4730.png?raw=true)
![img](/resources/4535.png?raw=true)

  <br>

- On a finalement terminé la partie graphique de notre personnage.

---

- Maintenant, il faut pouvoir le contrôler. Alors c'est parti pour apprendre le `C#` et les modules de bases de Unity.

<br>

  - Tout d'abords les variables utiles à notre joueur :
```c
public bool activated = true;
public float speed = 10f, runningSpeed = 15f, turnSpeed = 200f;
public float jump = 6f;

public GameObject cameraAnchor;

private Rigidbody rb;
```

  - Ensuite les fonctions de base :

```c
void Start()
{
    rb = GetComponent<Rigidbody>();
}
```
```c
void Update()
{
    if (activated) {
        if (Input.GetKey(KeyCode.Space)) {
            rb.AddForce(rb.transform.up * jump, ForceMode.Impulse);
        }

        float finalSpeed = Input.GetKey(KeyCode.F) ? runningSpeed : speed;

        if (Input.GetKey(KeyCode.S)) {
            rb.AddForce(rb.transform.forward * finalSpeed, ForceMode.Acceleration);
        }
        if (Input.GetKey(KeyCode.W)) {
            rb.AddForce(-rb.transform.forward * finalSpeed, ForceMode.Acceleration);
        }
        if (Input.GetKey(KeyCode.Q)) {
            rb.AddForce(-rb.transform.right * finalSpeed, ForceMode.Acceleration);
        }
        if (Input.GetKey(KeyCode.D)) {
            rb.AddForce(rb.transform.right * finalSpeed, ForceMode.Acceleration);
        }
        if (Input.GetKey(KeyCode.A)) {
            transform.Rotate(Vector3.up, -turnSpeed * Time.deltaTime);
        }
        if (Input.GetKey(KeyCode.D)) {
            transform.Rotate(Vector3.up, turnSpeed * Time.deltaTime);
        }
    }
}
```

  - Premier problème rencontré : le joueur n'a pas de limite de vitesse ! C'est un problème très facilement solvable par une simple condition :
```c
void Update()
{
        //...
        if(rb.velocity.magnitude > finalSpeed) {
            rb.velocity = rb.velocity.normalized * finalSpeed;
        }
    }
}
```

  - Et tout fonctionnait très bien mais là. **Terrible problème !** Quand on appuie sur `[SPACE]`, on saute beaucoup beaucoup trop haut.

  - Après de longue minutes de réflexion, c'est évident, il faut un **cooldown** afin d'éviter de sauter 1 000 000 de fois en 0.1 sec :
```c
public bool isJumping;

IEnumerator JumpCooldown()
{
    isJumping = true;
    yield return new WaitForSeconds(0.1f);
    isJumping = false;
}

void Update()
{
        //...
        if (Input.GetKey(KeyCode.Space) && !isJumping) {
            rb.AddForce(rb.transform.up * jump, ForceMode.Impulse);
            isJumping = true;
            StartCoroutine(JumpCooldown());
        }
        //...
}
```

  - Et voilà un problème de réglé !!<br>
  Mais s'il n'y en avait qu'un, ça serait trop facile...

  - Le deuxième problème maintenant, c'est que si je tombe, je peux tout de même sauter... Alors il suffit simplement d'ajouter une dernière variable.
  > **Explications :** Pour pallier à ce problème, on va *imaginer* tracer un rayon (un __Raycast__), et on va analyser ce que ce rayon traverse. La fonction __Raycast__ renvoie un *true* si le rayon traverse un __collider__ *(de niveau 1 ou plus, ce qui évite les collisions avec les colliders du joueur ou encore les matières comme l'eau)*. C'est exactement ce que fait la ligne 5.
```c
public bool isGrounded;
public float groundDistance = 1.1f;

void CheckGrounded()
{
    isGrounded = Physics.Raycast(rb.transform.position, -rb.transform.up, groundDistance, 1);
}

void Update()
{
        //...
        CheckGrounded();
        if (Input.GetKey(KeyCode.Space) && isGrounded && !isJumping) {
            rb.AddForce(rb.transform.up * jump, ForceMode.Impulse);
            isJumping = true;
            StartCoroutine(JumpCooldown());
        }
        //...
}
```

  - Maintenant que notre personnage fonctionne parfaitement, on ajoute une dernière chose, le fait de pouvoir contrôler la caméra avec la souris, un geste bien plus naturel pour les joueurs (au lieu de devoir utiliser le clavier pour effectuer des rotations), tout en cachant le curseur, en le bloquant au centre de l'écran, et en imposant des limites verticales (pour ne pas retourner la caméra).
  > **Petite aparté :** Ce passage a été très intéressant et riche car calculer une rotation dans un univers tridimensionnel est très intéressant d'un point de vue mathématique.<br>
  En effet, on trouve 2 grands types de moyens pour calculer des rotations : les __Quaternions__ ainsi que les __Angles d'Euler__. Nous avons donc dû faire de nombreuses recherches pour comprendre ces systèmes et pour tenter de déterminer lequel était plus facilement manipulable dans ce contexte.<br>
  Quand les quaternions sont infiniment trop pratiques pour ajouter, soustraire et multiplier des rotations, les angles d'Euler sont quant à eux bien plus faciles à utiliser quand on souhaite définir ou calculer les bornes d'une rotation. Ils sont donc utilisés dans ce cas.
```c
public Vector2 mouseSensitivity = new Vector2(150f, 150f);

void Start() {
    // ...
    Cursor.lockState = CursorLockMode.Locked;
    Cursor.visible = false;
}

void Update()
{
        //...
        transform.Rotate(Vector3.up, Input.GetAxis("Mouse X") * mouseSensitivity.y * Time.deltaTime);
        if(cameraAnchor != null) {
            cameraAnchor.transform.Rotate(Vector3.right, -Input.GetAxis("Mouse Y") * mouseSensitivity.x * Time.deltaTime);
            float rot = cameraAnchor.transform.localEulerAngles.x;
            if (rot > 60 && rot < 290)
            {
                // 60 >= x° >= 0 || 360 >= x° >= 290
                bool tooLow = Mathf.Abs(rot - 60) < Mathf.Abs(rot - 290);
                cameraAnchor.transform.localEulerAngles = new Vector3(tooLow ? 60 : 290, 0, 0);
            }
        }
    }
}
```

- Et voilà un super personnage 100% jouable !

<br>

- Objectif la semaine prochaine : Créer un système de gravitation.


<br><br><br>


## Semaine 5 <a href="#semaine-6" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%87%EF%B8%8F%20NEXT&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a> <a href="#semaine-4" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%86%EF%B8%8F%20PREV&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a>

<div align="center">

  ## En plein dans les formules...

  > GitHub supporte le LateX donc c'est cool !

  ### Objectif : Créer notre propre système de gravitation.

</div>

- Notre jeu sera à base de réflexion et c'est pas mal de pouvoir jouer avec la gravité !

- Il nous fallait nous décider :

  - Changer la direction de la gravité quand on entre dans une zone par exemple *(donc utiliser la __Physique__ générale)*.

  - Coder son propre système de gravitation (qui pourrait donc être multiple).<br>
  Mais dans ce cas, comment procéder :

    - Définir une classe **`Attracteur`** avec les variables suivantes : *`forceAttraction` (nombre flottant)* ;

    - Ou définir une classe **`ZoneAttraction`** avec les variables suivantes : *`forceAttraction` (nombre flottant)*, *`directionAttraction` (vecteur tridimentionnel)*.

    > Dans les deux cas, il fallait une classe **`Attractif`** qui subirait (calculerait) toutes les interactions gravitationnelles.

- Mais en essayant de bidouiller les valeurs du module **Physics** de Unity, on s'est vite rendu compte qu'il n'était pas possible de gérer *"plusieurs gravités"*.

- Et le fait d'avoir un *"point d'attraction"* est en réalité un peu contraignant dans notre situation : le sol est bien droit et bien horizontal donc on veut pouvoir par défaut être attiré vers le bas et non vers le centre de la pièce.
> **Remarque :** *Même si cette idée n'est pas du tout à écarter pour d'autres types de projets.*<br>
**Exemple :** *Sur un jeu où notre avatar devrait se déplacer sur plusieurs planètes (__Super Mario Galaxy__ par exemple), cette solution est la meilleure de très loin.*

<br>

---

<br>

- Donc pour créer nos *"zones d'attraction"*, il nous fallait nous renseigner sur... **Comment simuler la gravité ?**

- Mais en réalité, après plusieurs temps de reflexion... le principe est très simple :

<div align="center">

  $${\huge \text{Chaque element qui subit la gravite a une masse } m \text{.}}$$

  $${\huge \text{Nous connaissons egalement le vecteur constant de gravitation } \vec{\Gamma} \text{.}}$$

  $${\huge \text{Unity possede, pour reguler les calculs, une variable de temps } \delta \text{.}}$$

  <br>

  $${\huge \text{L'acceleration que subit un objet est donc :}}$$

  $${\huge \vec{\alpha} = m \times \vec{\Gamma} \times \delta}$$

</div>

- On a donc commencé le travail :

> **Remarque :** *Toutes les classes affichées sont évidemment incomplètes, ne laissant que les bouts de code "intéressants".*

`GravityMotor.cs` :
```csharp
public bool activated = true;
// Liste des zones dans lesquelles l'entité se trouve.
public List<GravityArea> gravityAreas = new List<GravityArea>();

private Rigidbody rb;

[SerializeField] Vector3 Gravity
{
    get
    {
        if (gravityAreas.Count == 0)
            return Vector3.zero;
        GravityArea area = gravityAreas.Last();
        return area.gravityDirection * area.gravityStrength;
    }
}

void FixedUpdate()
{
    if (activated)
    {
        rb.AddForce(Gravity * rb.mass * Time.deltaTime, ForceMode.Acceleration);
    }
}
```

`GravityArea.cs` :
```csharp
public bool activated = true;
public float gravityStrength = 900f;
public Vector3 gravityDirection = Vector3.down;

// Quand une entité entre dans la zone.
void OnTriggerEnter(Collider other)
{
    if(other.TryGetComponent(out GravityMotor motor))
    {
        if(activated)
            motor.gravityAreas.Add(this);
        else
            motor.gravityAreas.Remove(this);
    }
}

// Quand une entité sort dans la zone.
void OnTriggerExit(Collider other)
{
    if (other.TryGetComponent(out GravityMotor motor))
    {
        motor.gravityAreas.Remove(this);
    }
}
```

- Ça a fonctionné pendant... ${\large \approx 10 \text { secondes.}}$

- Le problème était que le joueur ... tombait. Il se retrouvait après quelques secondes sur le flanc.

- Impossible d'avancer ni même de rester sans bouger.

- On a dû trouver une solution : (dans `GravityMotor.cs`)
```csharp
void Start()
{
    rb = GetComponent<Rigidbody>();
    rb.constraints = RigidbodyConstraints.FreezeRotation;
    /*
     * Avec cette contrainte, normalement, il est impossible
     *  "naturellement" de changer sa rotation.
     * Seul un script peut mettre à jour la rotation.
     *  --> C'est exactement ce qu'on veut !
     */
}
```

- Mais cette fois-ci, quand on changeait de zone de gravitation.. on restait figés dans la même direction.<br>
On était donc *"allongé"* sur le *"nouveau sol"*. Et ça, c'est un problème.

- On avait donc plus qu'à trouver un moyen de changer notre direction pour rester toujours vertical **par rapport à notre gravité actuelle $\vec{\Gamma}$**.

- Ça sonnait simple mais en réalité, ça ne l'était pas du tout.

- On a essayé beaucoup de choses :

  - Figer la rotation $y$ du perso,
  > Mais dans ce cas, le joueur ne peut pas s'adapter à son environnement.

  - Définir la rotation $y$ à l'inverse de la coordonnée $y$ du vecteur gravité $\vec{\Gamma}$
  > Mais si ça n'est pas la position $y$ qui est non-nulle dans $\vec{\Gamma}$...

  - Ajouter la rotation actuelle à l'inverse du vecteur $\vec{\Gamma}$
  > **Mais comment faire ça...**

<br>

- Pour étudier la rotation d'un objet dans l'espace, on trouve 2 grands types de moyens pour calculer des rotations : les __Quaternions__ ainsi que les __Angles d'Euler__.

  - Les __Angles d'Euler__ sont un *triplet* de *nombres flottants*, avec des exprimé en *degrés* donc ça semblait formidable. Mais les mesures sont __arbitraires__, c'est-à dire qu'elles peuvent changer, en fonction de la rotation et de la position dans le monde, de référentiel.

  - Tandis que les [__Quaternions__](https://fr.wikipedia.org/wiki/Quaternion) sont une branche des nombres imaginaires exprimés sous la forme : ${\large a + bi + cj + dk, \left ( a ; b ; c ; d \right ) \in \mathbb{R}^{4}}$ qui représente les rotations de manière bien plus complexes à comprendre mais également bien plus simple à manipuler, à bases d'opérations élémentaires.

### C'est ici qu'a commencé l'étude des Quaternions

- En effet, même si par la suite, toutes les recherches effectuées ne seront pas utilisées à leur plein potentiel dans le cadre de ce problème, elles ont permis la découverte et la compréhension de très beaux et de très ingénieux principes mathématiques.
> Un exemple est juste le principe de multiplication : les formules de multiplications des quaternions sont très proches des multiplications matricielles et permettent une parfaite manipulation des coordonnées, vecteurs et rotations dans l'espace.

<br>

- Enfin bref, après cette découverte formidable, la question nous paraissait d'une simplicité monstrueuse !

- Les trois lignes de code requises nous ont paru d'un naturel sans égale : (dans `GravityMotor.cs`)
```csharp
public bool activated = true;

//...

    // Dans le FixedUpdate()
    if (rotate)
    {
        Quaternion rotation = Quaternion.FromToRotation(transform.up, -gravity) * transform.rotation;
        rotation = Quaternion.Slerp(transform.rotation, rotation, 10f * Time.deltaTime);
        transform.rotation = rotation;
    }

// ...
```

<br>

- Notre problème était enfin résolu !

- Un dernier subsistait encore : **La superposition des Zones**.

- Qu'on a réglé avec un simple système de priorité :

`GravityZone.cs` :
```csharp
public int priority = 0;
// ...
```
`GravityMotor.cs` :
```csharp
Vector3 Gravity
{
    get
    {
        // ...
        gravityAreas.Sort((area1, area2) => area1.priority.CompareTo(area2.priority));
        // ...
    }
}
```

<br>

- Et voilà. **Tout notre système de gravité est opérationnel !!**

- Quelques screenshots de la *TestRoom*.

![img](/resources/0362.png?raw=true)

![img](/resources/9329.png?raw=true)


<br><br><br>


## Semaine 10 <a href="#semaine-11" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%87%EF%B8%8F%20NEXT&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a> <a href="#semaine-5" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%86%EF%B8%8F%20PREV&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a>

- Ajout de 2 salles
- Amélioration de la détection des cubes sur les plaques de pression
- Correction de bugs sur le mouvement des cubes
- Menu des options créé


<br><br><br>


## Semaine 11 <a href="#semaine-12" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%87%EF%B8%8F%20NEXT&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a> <a href="#semaine-10" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%86%EF%B8%8F%20PREV&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a>

- Ajout d'une salle
- Nettoyage du mouvement de la caméra lors du changement de gravité
- Ecran titre et menu de pause améliorés


<br><br><br>


## Semaine 12 <a href="#semaine-13" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%87%EF%B8%8F%20NEXT&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a> <a href="#semaine-11" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%86%EF%B8%8F%20PREV&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a>

- Ajout d'une narration
- Ajout d'effets sonores
- Paramétrage de la physique du personnage


<br><br><br>


## Semaine 13 <a href="#semaine-13" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%87%EF%B8%8F%20NEXT&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a> <a href="#semaine-12" align="right"><img src="https://img.shields.io/static/v1?message=%E2%AC%86%EF%B8%8F%20PREV&logo=&label=&color=7289DA&logoColor=white&labelColor=&style=for-the-badge" height="35" alt="up" align="right" /></a>

- Ajout de sous-titres pour la narration
- Amélioration des menus
- Correction de bugs mineurs par rapport aux contrôles
- Finalisation du projet
- Création d'une vidéo et d'un flyer

---

<br><br>

# Images complémentaires

![img](/resources/0934.png?raw=true)

![img](/resources/2891.png?raw=true)

![img](/resources/3084.png?raw=true)

![img](/resources/4152.png?raw=true)

![img](/resources/4285.png?raw=true)

![img](/resources/5348.png?raw=true)

![img](/resources/7296.png?raw=true)

![img](/resources/9954.png?raw=true)

<br><br>

# Site

https://cydroid.webflow.io

---

<br><br>

## Teasers

![Cydroïd](https://github.com/Luzog78/Cydroid/assets/55955510/caa1a813-f2b9-4c34-8dcf-484ffa237709)

---
